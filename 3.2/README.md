### Summary - Attribute Grammars
* lexical analysis establishes local relationships between characters
* syntax analysis establishes nesting relationships between tokens
* context handling establishes long range relationships between variables/AST nodes
* conceptually - attributes stored in nodes
* implementation - attributes stored in symbol tables
* all context handling is based on data flow machines, all context handling techniques are implementations of data flow machines
* starting info for context handling is AST nodes, with its classes and representations
* context handlers can be written by hand or automatically generated
* each non terminal and terminal in attribute grammars has its own set of formal attributes
* a formal attribute is a named property
* an actual attribute is a named property and a paired value
* each node for a non terminal and terminal S has the formal attributes of S, values may and usually do differ
* for each S, evaluation rules are evaluated, synthesizing rules, and inheriting rules from parents
* data dependancies can be represented in a dependancy graph for rule P for node S
* inherited attributes correspond to input parameters and synthesized attributes to output parameters - don't need to be computed in any orders. 
* given an AST, we can compute more and more attributes, until all have been computed or a loop has been detected
* naive way - visit all nodes repeatedly until all values have been set - called dynamic attribute evaluation
* inefficient, does not terminate if there is a cycle in attribute dependancies
* static attribute evaluation determines attribute evaluation order at compiler runtime, not construction time
* efficient, detects cycles at compiler generation time, more complicated
* static attribute evaluation order determined by IS-SI graphs and late evaluation by topographical sort. all properties determined at compiler construction time
* nodes in IS_SI graph of non terminal N are attributes of N, arrows are data dependancies between them. summary can be determined at compiler construction time, before any AST is actually constructed
* IS_SI graph of N depends on dependancy graphs of production rules in which N occurs and IS_SI graphs of other non-terminals in production rules
* this defines recurrency relations. recurrency relations are solved by transitive closure to determine all IS_SI graphs
* if there is evaluation cycle in attribute grammar, attribute will depend on itself. at least one of IS_SI graphs will exhibit a cycle. this provides cycle detection at compiler construction time.
* multi-visit attribute evaluator visits node for non-terminal N 1 or more times, IN = set attributes, SN = attributes set after visit
* this defines attribute partitioning (IN, SN) for each node. IN = all inherited attributes, SN = all synthesized attributes
* given acceptable partitioning, multi-visit code can be generated by finding child whose IN set allows visit, generating code for it, and repeat process.
* if partitioning is acceptable, this can be done without violating data dependancies
* partitionings can be seen as additional data dependancies, to be merged with original data dependancies. if result is still cyle free, partitioning is acceptable
* must choose partitioning of IS_SI graph carefully, to prevent creating additional dependancies that could create cycles
* in an ordered attribute evaluation, late partitioning of all IS_SI graphs yeilds acceptable partitioning
* in late partitioning, all synthesized attributes which no other attributes depend on are evaluated last
* once late partitioning has been obtained, cycle testing algorithm can test it for us, or generate code and see if it gets stuck. if stuck, attribute was not ordered grammar.
